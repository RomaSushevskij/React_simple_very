# UseEffect, cleanup (сброс, зачистка)
 Для того, чтобы сбросить эффект, нужно из функции, переданной в `useEffect`, вернуть **другую функцию**, код которой и будет сбрасывать этот эффект.
 
 **Эта функция** будет вызываться:
  - когда компонента умирает;
  - перед очередным вызовом этого эффекта;
  
То есть, если в `useEffect` указаны в зависимостях данные из локального `state` компонены, например, то **при изменении этих данных** порядок вызовов будет следующий:

1. Рендер компоненты.
2. Регистрация нового `useEffect`.
3. Вызов функции, которую возвращаем из `useEffect` => зачистка предыдущего `useEffect`.
4. Вызов нового `useEffect`. 

В качестве примера смотреть [Common.tsx](./Common/Common.tsx) и [Common.stories.tsx](./Common/Common.stories.tsx)
  
### Когда и где нужна зачистка эффекта

- При использовании `setUnterval` и `setTimeout` в `useEffect`
- При осуществлении `запроса на сервер`, недожидаясь окончания запроса уходим из компоненты. Компонента соответственно умирает и нам уже не нужно пришедшие с сервера данные заносить в `state`. Это делается не часто, но по правильному нужно делать именно так.
- При подписке на события каких-то нативных элементов через `addEventListener`. (Например трекаем всё, что печатается в document, в том числе за пределами компоненты, и отображение где-то. 
`window.addEventListener('keypress', (e) => { console.log(e.key) 
 setText(text + e.key)})`. Тогда в зависимости `useEffect` добавить `text` или использовать в `setText` функцию-преобразователь). 
При этом очистку осуществляем через `removeEventListener`; и важно, чтобы слушатель ссылался на один и тот же объект при добавлении и отмене (то есть функцию-флушатель нужно присвоить отдельной переменной). Пример: [KeysTracker.tsx](./KeysTracker/KeysTracker.tsx) и [KeysTracker.stories.tsx](./KeysTracker/KeysTracker.stories.tsx)


  
 
